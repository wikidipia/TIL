## 클로저(`closure`)

* 람다식으로 표현된 내부 함수에서 외부 범위에 선언된 변수에 접근할 수 있는 개념
* 람다식 안에 있는 외부 변수는 값을 유지하기 위해 람다가 포획(`capture`)한 변수

```kotlin
fun main(){
    val calc = Calc()
    var result = 0 // 외부의 변수
    calc.addNum(2,3) { x,y -> result = x + y } // 클로저
    println(result) // 값을 유지하여 5가 출력
}

class Calc {
    fun addNum(a:Int, b: Int, add: (Int,Int) -> Unit){ // 람다식 add에는 반환값 없음
        add(a,b)
    }
}
```

* 함수의 매개변수에 접근

```kotlin
fun filterdNames(length: Int){
    val names = arrayListOf("Kim","Hong","Go","Hwang","Jeon")
    val filterResult = names.filter {
        it.filter == length // 바같의 length에 접근
    }
    println(filterResult)
}
```

> 함수 자체를 같이 포획해 해당 매개변수에 접근한다.

## 표준함수

* 람다식을 사용하는 Kotlin의 표준 라이브러리에서 여러 가지 표준 함수를 제공하고 있다.
* 표준 함수들은 대략 확장 함수 형태의 람다식으로 구성되어 있다.

### `let()`

* `let`의 동작
    * 함수를 호출하는 객체 `T`를 이어지는 `block`의 인자로 넘기고 `block`의 결과값 `R`을 반환한다.

    ```kotlin
    public inline fun <T,R> T.let(block: (T) -> R): R {... return block(this)}
    ```

    * 매개변수 `block`은 `T`를 매개변수로 받아 `R`을 반환
    * `let()`함수 역시 `R`을 반환
    * 본문의 `this`는 객체 `T를 가르키는데 람다식 결과 부분을 그대로 반환한다는 뜻
    * 다른 메서드를 실행하거나 연산을 수행해야 하는 경우 사용

```kotlin
fun main(){
    val score: Int? = 32
    //var score = null

    // 일반적인 null 검사
    fun checkScore(){
        if (score != null){
            println("Score: $score")
        }
    }

    // let을 사용해 null 검사를 제거
    fun checkScoreLet(){
        score?.let { println("Score: $it") }
        val str = score.let { it.toString() }
        println(str)
    }

    checkScore()
    checkScoreLet()
}
```

* `let` 함수의 체이닝(chaining)

```kotlin
fun main(){
    var a = 1
    var b = 2

    a = a.let{it+2}.let{
        println("a=$a")
        val i = it + b
        i
    }

    println(a) //5
}
```

* 중첩 사용

```kotlin
var x = "Kotlin!"
    x. let { outer ->
        outer.let{ inner ->
            print("Inner is $inner and outer is $outer") // 이때는 it을 사용하지 않고 명시적 이름을 사용한다.
        }
    }
```

* 반환값은 바깥쪽의 람다식에만 적용

```kotlin
var x = "Kotlin!"
    x. let { outer ->
        outer.let{ inner ->
            print("Inner is $inner and outer is $outer") // 이때는 it을 사용하지 않고 명시적 이름을 사용한다.
            "Inner String" // 이것은 반환되지 않음
        }
        "Outer String" // 이 문자열이 반환되 x에 할당된다.
    }
```

* `null` 검사
    * `let`을 세이프 콜과 함께 사용하면 `if (null != obj)`와 같은 `null` 검사 부분을 대체할 수 있다.

```kotlin
var obj: String?

...

if (null != obj){
    Toast.makeText(...)
}
```

```kotlin
obj?.let{
    Toast.makeText(...)
}
```
> 두 방법이 같다.

* `else`문이 포함된 문장 대체

```kotlin
val firstName: String?
val lastName: String

if (null != fistName){
    print("$firstName $lastName")
} else {
    print("$lastName")
}
```

```kotlin
firstName?.let { print("$it $lastName") } ?: print("$lastName")
```